<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Exported Scene</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <style>
    /* Define the Klapt font */
    @font-face {
      font-family: "Klapt";
      src: url("fonts/Klapt-Medium.otf") format("opentype");
      font-weight: 500;
      font-style: normal;
    }
    @font-face {
      font-family: "Klapt";
      src: url("fonts/Klapt-Bold.otf") format("opentype");
      font-weight: 700;
      font-style: normal;
    }

    /* Base styles */
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
      font-family: Arial, sans-serif;
    }
    #renderCanvas {
      width: 100%;
      height: 100%;
      touch-action: none;
    }

    /* UI overlay (unchanged) */
    .ui-overlay {
      position: absolute;
      top: 10px;
      left: 10px;
      background-color: rgba(0,0,0,0.7);
      padding: 15px;
      border-radius: 10px;
      color: white;
      z-index: 10;
      font-size: 14px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      display: none;
    }

    /* Hotspot content (unchanged) */
    #hotspotContent {
      position: fixed;
      background-color: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 20px;
      border-radius: 10px;
      z-index: 1001;
      max-width: 300px;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
      display: none;
      font-size: 14px;
    }

    /* Info popup (unchanged) */
    #infoPopup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 20px;
      border-radius: 10px;
      z-index: 1002;
      max-width: 80%;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
      display: none;
      font-size: 16px;
    }

    /* Scroll controls container */
    #scrollControls {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(62, 62, 62, 0.35);
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      padding: 8px 10px;
      border-radius: 60px;
      color: white;
      z-index: 1000;
      box-shadow: 0 4px 4px rgba(0, 0, 0, 25%);
      display: none;
    }

    #toggleCameraModeContainer {
      margin-bottom: 10px;
    }

    #scrollControlsContent,
    #exploreControlsContent {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: opacity 0.3s ease-in-out;
      width: 100%;
    }

    #scrollControlsContent.hidden,
    #exploreControlsContent.hidden {
      opacity: 0;
      pointer-events: none;
      position: absolute;
    }

    #exploreControlsContent p {
      color: white;
      font-size: 14px;
      text-align: center;
      margin: 0;
    }

    #scrollPercentage {
      font-size: 18px;
      margin-bottom: 10px;
    }

    #progressBarContainer {
      width: 200px;
      height: 10px;
      background-color: rgba(255,255,255,0.3);
      border-radius: 5px;
      overflow: hidden;
      margin-bottom: 10px;
    }

    #progressBar {
      width: 0%;
      height: 100%;
      background-color: #4CAF50;
      transition: width 0.3s ease;
    }

    /* Updated scroll buttons with SVG styling */
    #scrollButtons {
      display: flex;
      justify-content: space-between;
      gap: 20px;
    }

    #scrollButtons svg {
      cursor: pointer;
    }

    #scrollButtons svg.left_arrow:hover rect,
    #scrollButtons svg.right_arrow:hover rect,
    #scrollButtons svg.play_btn:hover rect.c {
      fill: #ffffff;
    }

    #scrollButtons svg.play_btn:hover rect.d {
      fill: #222222;
    }

    #scrollButtons svg.left_arrow:hover path,
    #scrollButtons svg.right_arrow:hover path {
      stroke: #222222;
    }

    /* Mute button (unchanged) */
    #muteButton {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: rgba(0,0,0,0.7);
      color: white;
      border: none;
      padding: 10px;
      border-radius: 5px;
      cursor: pointer;
      z-index: 1000;
    }

    /* Preloader (unchanged) */
    #preloader {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #1e1e1e;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100000;
      transition: opacity 0.5s ease-out;
    }

    #preloader.hidden {
      opacity: 0;
      pointer-events: none;
    }

    #preloader h1 {
      font-size: 48px;
      color: #ffffff;
      text-align: center;
      font-family: 'Courier New', monospace;
    }

    #preloader .spinner {
      width: 25px;
      height: 25px;
      border: 5px solid #ffffff;
      border-top: 5px solid #F76900;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    #startButtonContainer {
      position: absolute;
      width: 100%;
      height: 100%;
      background-color: rgba(255, 255, 255, 0.2);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10000;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    #startButton {
      padding: 20px 40px;
      font-size: 24px;
      background-color: rgba(255, 255, 255, 0.25);
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }

    #toggleCameraMode {
      background-color: #4CAF50;
      border: none;
      color: white;
      padding: 10px 20px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-size: 16px;
      margin: 4px 2px;
      cursor: pointer;
      border-radius: 5px;
      transition: background-color 0.3s;
    }

    #toggleCameraMode:hover {
      background-color: #197c1d;
    }

    #joystickContainer {
      position: absolute;
      bottom: 50px;
      left: 50px;
      z-index: 1000;
    }

    #joystickCanvas {
      width: 100px;
      height: 100px;
      touch-action: none;
    }

    /* Updated Waypoint UI Styles */
    .gradient-box {
      position: fixed;
      width: 305px;
      height: 860px;
      top: 0;
      left: 0;
      background: linear-gradient(271deg, rgba(0, 0, 0, 0) 0.86%, #000 99.05%);
      z-index: 999;
    }

    #waypointContainer {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    #waypointControls {
      max-height: 600px;
      overflow-y: auto;
      overflow-x: hidden;
      display: flex;
      flex-direction: column;
      gap: 5px;
      width: 100%;
    }

    #waypointControls::-webkit-scrollbar {
      width: 8px;
    }

    #waypointControls::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.5);
    }

    #waypointControls::-webkit-scrollbar-thumb {
      background: #888;
      border-radius: 4px;
    }

    #waypointControls::-webkit-scrollbar-thumb:hover {
      background: #555;
    }

    #waypointTitle {
      color: #ffffff;
      font-family: "Klapt";
      font-weight: 700;
      font-size: 20px;
      text-align: center;
      margin-bottom: 20px;
    }

    .waypoint-button {
      height: 53px;
      width: 211px;
      background-color: #ffffff;
      border: none;
      cursor: pointer;
      font-family: "Klapt";
      font-weight: 500;
      font-size: 13px;
      color: #000000;
      text-align: center;
      margin-bottom: 10px;
      border-radius: 5px;
    }

    .waypoint-button:hover,
    .waypoint-button.active {
      background-color: #222222;
      color: #ffffff;
    }

    /* Updated bottom text styles */
    #waypointText {
      position: absolute;
      width: 614px;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-family: "Klapt";
      font-weight: 500;
      color: #ffffff;
      font-size: 20.1px;
      text-align: center;
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #waypointText img {
      width: 13px;
      height: 57px;
      margin: 0 10px;
    }

    #waypointText .text-content {
      flex: 1;
    }

    /* Action buttons */
    #actionButtons {
      position: absolute;
      bottom: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 1000;
    }

    #resetViewButton,
    #exitButton {
      height: 53px;
      width: 211px;
      background-color: #ffffff;
      border: none;
      cursor: pointer;
      font-family: "Klapt";
      font-weight: 500;
      font-size: 13px;
      color: #000000;
      text-align: center;
      border-radius: 5px;
    }

    #resetViewButton:hover,
    #exitButton:hover {
      background-color: #222222;
      color: #ffffff;
    }
  </style>
</head>
<body>
  <div id="preloader">
    <h1>MetaShop AI</h1>
    <div class="spinner"></div>
  </div>
  <div id="startButtonContainer">
    <button id="startButton">Start Experience</button>
  </div>
  <canvas id="renderCanvas"></canvas>
  <div class="ui-overlay">
    <p><strong>Controls:</strong></p>
    <p>• W/A/S/D: Move camera</p>
    <p>• Q/E: Up and Down</p>
    <p>• Mouse: Look around</p>
    <p>• Scroll: Move along path</p>
  </div>
  <div id="hotspotContent"></div>
  <div id="infoPopup"></div>
  <div id="scrollControls">
    <div id="toggleCameraModeContainer">
      <button id="toggleCameraMode" onclick="toggleCameraMode()">Mode: Tour</button>
    </div>
    <div id="scrollControlsContent">
      <div id="scrollPercentage">0%</div>
      <div id="progressBarContainer">
        <div id="progressBar"></div>
      </div>
      <div id="scrollButtons">
        <svg class="left_arrow" onclick="handleButtonScroll(-1)" width="40" height="40" viewBox="0 0 53 52" fill="none" xmlns="http://www.w3.org/2000/svg">
          <rect x="0.5" width="52" height="52" rx="26" fill="#222222" />
          <path d="M30.5 17L18.7133 25.84C18.6067 25.92 18.6067 26.08 18.7133 26.16L30.5 35" stroke="white" stroke-width="3" stroke-linecap="round" />
        </svg>
        <svg class="play_btn" onclick="togglePlayPause()" width="40" height="40" viewBox="0 0 53 52" fill="none" xmlns="http://www.w3.org/2000/svg">
          <rect class="c" x="0.5" width="52" height="52" rx="26" fill="#222222" />
          <rect class="d" x="20.5" y="14" width="4.4" height="23.76" rx="0.88" fill="white" />
          <rect class="d" x="28.9" y="14" width="4.4" height="23.76" rx="0.88" fill="white" />
        </svg>
        <svg class="right_arrow" onclick="handleButtonScroll(1)" width="40" height="40" viewBox="0 0 53 52" fill="none" xmlns="http://www.w3.org/2000/svg">
          <rect width="52" height="52" rx="26" transform="matrix(-1 0 0 1 52.5 0)" fill="#222222" />
          <path d="M22.5 17L34.2867 25.84C34.3933 25.92 34.3933 26.08 34.2867 26.16L22.5 35" stroke="white" stroke-width="3" stroke-linecap="round" />
        </svg>
      </div>
    </div>
    <div id="exploreControlsContent" class="hidden">
      <p>Use WASD to move and mouse to look around</p>
    </div>
  </div>
  <button id="muteButton">🔊 Mute</button>
  <!-- Updated Waypoint UI -->
  <div class="gradient-box"></div>
  <div id="waypointContainer">
    <div id="waypointTitle">TAKE A CLOSER LOOK</div>
    <div id="waypointControls"></div>
  </div>
  <div id="waypointText">
    <img src="Openbracket.svg" alt="Open Bracket" />
    <span class="text-content"></span>
    <img src="Closebracket.svg" alt="Close Bracket" />
  </div>
  <!-- Action Buttons -->
  <div id="actionButtons">
    <button id="resetViewButton">RESET VIEW</button>
    <button id="exitButton">EXIT</button>
  </div>

  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
  <script>
    let cameraMode = 'tour';
    const allowedCameraModes = ["tour", "explore", "auto"];
    let loopMode = false;
    let autoPlaySpeed = 0.05;
    let autoPlayEnabled = false;
    let lastClickedButton = null;

    // Define individual names for waypoint buttons
    const waypointNames = [
      "Aerial View",       // Waypoint 6
      "The Pier",       // Waypoint 7
      "The Lawn Aerial View",       // Waypoint 8
      "Parking Aerial",       // Waypoint 9
      "Restaurant",       // Waypoint 10
      "Seaside Bungalows",       // Waypoint 11
      "Lawn + Stage Views", // Waypoint 1
      "Lawn + Stage Views", // Waypoint 2
      "Lawn + Stage Views", // Waypoint 3
      "Lawn + Stage Views", // Waypoint 4
      "Pool View",          // Waypoint 5
      
    ];

    const pauseSVG = `<rect class="c" x="0.5" width="52" height="52" rx="26" fill="#222222" />
                      <rect class="d" x="20.5" y="14" width="4.4" height="23.76" rx="0.88" fill="white" />
                      <rect class="d" x="28.9" y="14" width="4.4" height="23.76" rx="0.88" fill="white" />`;

    const playSVG = `<rect x="0.5" width="52" height="52" rx="26" fill="#222222"/>
                     <path d="M39.36 24.4758C40.5333 25.1532 40.5333 26.8468 39.36 27.5242L22.14 37.4662C20.9667 38.1436 19.5 37.2968 19.5 35.942V16.058C19.5 14.7032 20.9667 13.8564 22.14 14.5338L39.36 24.4758Z" fill="white"/>`;

    function updateScrollControlsVisibility() {
      const scrollControlsContent = document.getElementById('scrollControlsContent');
      const exploreControlsContent = document.getElementById('exploreControlsContent');
      if (cameraMode === 'explore') {
        scrollControlsContent.classList.add('hidden');
        exploreControlsContent.classList.remove('hidden');
      } else {
        scrollControlsContent.classList.remove('hidden');
        exploreControlsContent.classList.add('hidden');
      }
    }

    function toggleCameraMode() {
      const currentIndex = allowedCameraModes.indexOf(cameraMode);
      const nextIndex = (currentIndex + 1) % allowedCameraModes.length;
      cameraMode = allowedCameraModes[nextIndex];
      const toggleButton = document.getElementById('toggleCameraMode');
      toggleButton.textContent = 'Mode: ' + cameraMode.charAt(0).toUpperCase() + cameraMode.slice(1);
      if (cameraMode === 'tour') {
        userControl = false;
      } else if (cameraMode === 'explore') {
        userControl = true;
      }
      if (BABYLON.VirtualJoystick.Canvas && (cameraMode === 'explore' || cameraMode === 'auto')) {
        BABYLON.VirtualJoystick.Canvas.style.zIndex = "10";
      } else if (BABYLON.VirtualJoystick.Canvas && cameraMode === 'tour') {
        BABYLON.VirtualJoystick.Canvas.style.zIndex = "-10";
      }
      updateScrollControlsVisibility();
    }

    function togglePlayPause() {
      userControl = !userControl;
      autoPlayEnabled = !userControl;
      const playPauseButton = document.querySelector(".play_btn");
      playPauseButton.innerHTML = !userControl ? pauseSVG : playSVG;
      updateScrollControlsVisibility();
    }

    updateScrollControlsVisibility();

    const preloader = document.getElementById('preloader');
    const canvas = document.getElementById('renderCanvas');
    const engine = new BABYLON.Engine(canvas, true);
    const scene = new BABYLON.Scene(engine);
    window.scene = scene;

    scene.clearColor = BABYLON.Color3.FromHexString('#7D7D7D').toColor4(1);

    const camera = new BABYLON.UniversalCamera(
      'camera',
      new BABYLON.Vector3(-95.36336010864613, 60.70026961684986, -131.71192087399493),
      scene
    );
    camera.attachControl(canvas, true);
    camera.speed = 0.33;
    camera.angularSensibility = 4000;
    camera.rotationQuaternion = new BABYLON.Quaternion(
      0.21264220614542506,
      -0.2845310777295716,
      0.06488068635176783,
      0.9325319580758583
    ).normalize();
    camera.rotation = camera.rotationQuaternion.toEulerAngles();
    camera.keysUp.push(87); // W
    camera.keysDown.push(83); // S
    camera.keysLeft.push(65); // A
    camera.keysRight.push(68); // D
    camera.keysUpward.push(81); // Q
    camera.keysDownward.push(69); // E
    camera.inputs.addGamepad();

    let userControl = cameraMode === 'explore';
    let animatingToPath = false;

    const isMobileDevice = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(
      navigator.userAgent.toLowerCase()
    );

    if (isMobileDevice) {
      var leftJoystick = new BABYLON.VirtualJoystick(true);
      var rightJoystick = new BABYLON.VirtualJoystick(false);
      if (cameraMode === 'tour') {
        if (BABYLON.VirtualJoystick.Canvas) {
          BABYLON.VirtualJoystick.Canvas.style.zIndex = "-10";
        }
      } else {
        if (BABYLON.VirtualJoystick.Canvas) {
          BABYLON.VirtualJoystick.Canvas.style.zIndex = "10";
        }
      }
      scene.onBeforeRenderObservable.add(() => {
        if (leftJoystick.pressed) {
          userControl = true;
          const deltaTime = engine.getDeltaTime() / 1000;
          const moveSpeed = deltaTime * 5 * 0.33;
          const moveX = leftJoystick.deltaPosition.x * moveSpeed;
          const moveZ = leftJoystick.deltaPosition.y * moveSpeed;
          const forward = camera.getDirection(BABYLON.Axis.Z);
          const right = camera.getDirection(BABYLON.Axis.X);
          const move = forward.scale(moveZ).add(right.scale(moveX));
          camera.position.addInPlace(move);
        }
        if (rightJoystick.pressed) {
          const deltaX = rightJoystick.deltaPosition.x;
          const deltaY = rightJoystick.deltaPosition.y;
          const angularSensibility = 200 * 0.33;
          const currentEuler = camera.rotationQuaternion.toEulerAngles();
          let yaw = currentEuler.y;
          let pitch = currentEuler.x;
          yaw += deltaX / angularSensibility;
          pitch -= deltaY / angularSensibility;
          const maxPitch = Math.PI / 2;
          pitch = Math.max(-maxPitch, Math.min(maxPitch, pitch));
          camera.rotationQuaternion = BABYLON.Quaternion.RotationYawPitchRoll(yaw, pitch, 0);
        }
      });
    }

    camera.checkCollisions = true;
    camera.applyGravity = false;
    camera.ellipsoid = new BABYLON.Vector3(0.1, 0.1, 0.1);

    new BABYLON.HemisphericLight('light', new BABYLON.Vector3(0, 1, 0), scene);

    let scrollPosition = 0;
    let scrollTarget = 0.01;

    const waypoints = [
    {"x":-715.4721557386447,"y":68.25170338684282,"z":-58.61908014802872,"rotation":{"_isDirty":true,"_x":-0.15206855887460854,"_y":0.7832897404747595,"_z":-0.5646522477264091,"_w":-0.21095062435566192},"interactions":[],"triggerDistance":1},
      {"x":-710.2312493956787,"y":50.91728260677708,"z":-75.2162238958396,"rotation":{"_isDirty":true,"_x":0.17423107716703892,"_y":-0.31902396037332514,"_z":0.05978863132111845,"_w":0.9296733630732376},"interactions":[],"triggerDistance":1},      
      {"x":-735.3377919337034,"y":55.69565295513268,"z":-61.41682925745362,"rotation":{"_isDirty":true,"_x":0.24754369251499883,"_y":0.6414506686663215,"_z":-0.23061609064555713,"_w":0.6885342140949854},"interactions":[],"triggerDistance":1},      
      {"x":-722.4101947928788,"y":60.49145812630799,"z":-53.5975999586379,"rotation":{"_isDirty":true,"_x":0.06336555357297688,"_y":0.8745217804620129,"_z":-0.46588476270448465,"_w":0.11894475590648838},"interactions":[],"triggerDistance":1},
      {"x":-719.175832294059,"y":49.546576804878605,"z":-72.50952755010654,"rotation":{"_isDirty":true,"_x":0.027102726371532482,"_y":-0.17392305397590183,"_z":0.0047886217366517915,"_w":0.9843745685758098},"interactions":[],"triggerDistance":1},      
      {"x":-701.7246299621036,"y":49.98916858186399,"z":-66.13403802340977,"rotation":{"_isDirty":true,"_x":0.03912734558763212,"_y":-0.7148470279843732,"_z":0.04012743148599868,"_w":0.6970312538731662},"interactions":[],"triggerDistance":1},
      {"x":-95.36336010864613,"y":60.70026961684986,"z":-131.71192087399493,"rotation":{"_isDirty":true,"_x":0.21264220614542506,"_y":-0.2845310777295716,"_z":0.06488068635176783,"_w":0.9325319580758583},"interactions":[],"triggerDistance":1},
      {"x":-97.94966025849592,"y":59.54632605666125,"z":-124.23227682392105,"rotation":{"_isDirty":true,"_x":0.06015778757618475,"_y":-0.36400278067740344,"_z":0.02356724306116693,"_w":0.929154235103792},"interactions":[],"triggerDistance":1},
      {"x":-100.49358636400088,"y":60.007455629187625,"z":-119.32709814436035,"rotation":{"_isDirty":true,"_x":0.07002775398502284,"_y":-0.5027328515435284,"_z":0.04090642086257386,"_w":0.8606291073207318},"interactions":[],"triggerDistance":1},
      {"x":-115.71028975542661,"y":60.356326696184766,"z":-108.42475357552712,"rotation":{"_isDirty":true,"_x":0.03745479716472715,"_y":0.8541577651482657,"_z":-0.06212960303491145,"_w":0.5149286654520475},"interactions":[],"triggerDistance":1},
      {"x":531.6163375837931,"y":171.81496648843407,"z":-30.172481036212897,"rotation":{"_isDirty":true,"_x":0.12254460084261586,"_y":0.36135506923448873,"_z":-0.047971357832358105,"_w":0.9230948314243933},"interactions":[],"triggerDistance":1}
      
    ];
    const controlPoints = waypoints.map(
      (wp) => new BABYLON.Vector3(wp.x, wp.y, wp.z)
    );
    const rotations = waypoints.map(
      (wp) => new BABYLON.Quaternion(wp.rotation._x, wp.rotation._y, wp.rotation._z, wp.rotation._w).normalize()
    );

    let path = [];
    if (controlPoints.length >= 2) {
      const positionCurve = BABYLON.Curve3.CreateCatmullRomSpline(controlPoints, 20, false);
      path = positionCurve.getPoints();
    } else if (controlPoints.length === 1) {
      path = [controlPoints[0]];
    }

    const hotspots = [];
    hotspots.forEach(hotspot => {
      const scale = (hotspot.scale._x === 0 && hotspot.scale._y === 0 && hotspot.scale._z === 0)
        ? new BABYLON.Vector3(1, 1, 1)
        : new BABYLON.Vector3(hotspot.scale._x, hotspot.scale._y, hotspot.scale._z);
      const sphere = BABYLON.MeshBuilder.CreateSphere(`hotspot-${hotspot.id}`, { diameter: 0.2 }, scene);
      sphere.position = new BABYLON.Vector3(hotspot.position._x, hotspot.position._y, hotspot.position._z);
      sphere.scaling = scale;
      const material = new BABYLON.StandardMaterial(`hotspot-material-${hotspot.id}`, scene);
      material.diffuseColor = BABYLON.Color3.FromHexString(hotspot.color);
      material.emissiveColor = BABYLON.Color3.FromHexString(hotspot.color).scale(0.5);
      sphere.material = material;
      sphere.isPickable = true;
      sphere.actionManager = new BABYLON.ActionManager(scene);
      sphere.actionManager.registerAction(
        new BABYLON.ExecuteCodeAction(
          BABYLON.ActionManager.OnPointerOverTrigger,
          () => {
            material.emissiveColor = BABYLON.Color3.FromHexString(hotspot.color);
            if (hotspot.activationMode === 'hover') {
              showHotspotContent(hotspot);
            }
          }
        )
      );
      sphere.actionManager.registerAction(
        new BABYLON.ExecuteCodeAction(
          BABYLON.ActionManager.OnPointerOutTrigger,
          () => {
            material.emissiveColor = BABYLON.Color3.FromHexString(hotspot.color).scale(0.5);
            if (hotspot.activationMode === 'hover') {
              hideHotspotContent();
            }
          }
        )
      );
      if (hotspot.activationMode === 'click') {
        sphere.actionManager.registerAction(
          new BABYLON.ExecuteCodeAction(
            BABYLON.ActionManager.OnPickTrigger,
            () => {
              showHotspotContent(hotspot);
            }
          )
        );
      }
    });

    function showHotspotContent(hotspot) {
      const hotspotContent = document.getElementById('hotspotContent');
      hotspotContent.innerHTML = `
        <h3>${hotspot.title}</h3>
        ${hotspot.photoUrl ? `<img src="${hotspot.photoUrl}" alt="${hotspot.title}" style="width: 100%; margin-bottom: 10px; border-radius: 5px;">` : ''}
        ${hotspot.information ? `<p>${hotspot.information}</p>` : ''}
        ${hotspot.activationMode === 'click' ? '<button onclick="hideHotspotContent()" style="width: 100%; padding: 10px; background-color: #4CAF50; border: none; color: white; cursor: pointer; border-radius: 5px;">Close</button>' : ''}
      `;
      hotspotContent.style.display = 'block';
      positionHotspotContent(hotspotContent);
    }

    function hideHotspotContent() {
      const hotspotContent = document.getElementById('hotspotContent');
      hotspotContent.style.display = 'none';
    }

    function positionHotspotContent(element) {
      const rect = element.getBoundingClientRect();
      let left = scene.pointerX + 10;
      let top = scene.pointerY + 10;
      if (left + rect.width > window.innerWidth) {
        left = window.innerWidth - rect.width - 10;
      }
      if (top + rect.height > window.innerHeight) {
        top = window.innerHeight - rect.height - 10;
      }
      element.style.left = `${left}px`;
      element.style.top = `${top}px`;
    }

    const collisionMeshesData = [];

    function createCollisionMeshes() {
      collisionMeshesData.forEach((data, index) => {
        const mesh = BABYLON.MeshBuilder.CreatePlane(`collisionMesh-${index}`, { size: 3 }, scene);
        mesh.position = new BABYLON.Vector3(data.position._x, data.position._y, data.position._z);
        mesh.rotation = new BABYLON.Vector3(data.rotation._x, data.rotation._y, data.rotation._z);
        mesh.scaling = new BABYLON.Vector3(data.scaling._x, data.scaling._y, data.scaling._z);
        mesh.checkCollisions = true;
        mesh.isVisible = false;
      });
    }

    createCollisionMeshes();

    let isMuted = false;
    const activeSounds = {};

    function playAudio(interactionData, waypointIndex) {
      if (isMuted) return;
      const id = interactionData.id;
      const url = interactionData.url;
      const data = interactionData;
      if (activeSounds[id] && activeSounds[id].isPlaying) return;
      if (activeSounds[id]) {
        if (!activeSounds[id].isPlaying) activeSounds[id].play();
      } else {
        const sound = new BABYLON.Sound(
          id,
          url,
          scene,
          () => { sound.play(); },
          {
            loop: data.loop !== undefined ? data.loop : true,
            volume: data.volume !== undefined ? data.volume : 1,
            spatialSound: data.spatialSound !== undefined ? data.spatialSound : false,
            distanceModel: data.distanceModel !== undefined ? data.distanceModel : "exponential",
            maxDistance: data.maxDistance !== undefined ? data.maxDistance : 100,
            refDistance: data.refDistance !== undefined ? data.refDistance : 1,
            rolloffFactor: data.rolloffFactor !== undefined ? data.rolloffFactor : 1,
          }
        );
        activeSounds[id] = sound;
        if (data.spatialSound) {
          let position = waypointIndex !== undefined && waypoints[waypointIndex]
            ? new BABYLON.Vector3(waypoints[waypointIndex].x, waypoints[waypointIndex].y, waypoints[waypointIndex].z)
            : new BABYLON.Vector3(0, 0, 0);
          sound.setPosition(position);
        }
      }
    }

    function stopAudio(interactionData) {
      const id = interactionData.id;
      const sound = activeSounds[id];
      if (sound && sound.isPlaying) sound.stop();
      delete activeSounds[id];
    }

    const executeInteractions = (interactions, waypointIndex) => {
      interactions.forEach((interaction) => {
        switch (interaction.type) {
          case "audio":
            playAudio({ ...interaction.data, id: interaction.id }, waypointIndex);
            break;
          case "info":
            showInfoPopup(interaction.data.text);
            break;
        }
      });
    };

    const reverseInteractions = (interactions) => {
      interactions.forEach((interaction) => {
        switch (interaction.type) {
          case "audio":
            const data = interaction.data;
            if (!data.spatialSound && data.stopOnExit) stopAudio({ ...data, id: interaction.id });
            break;
          case "info":
            hideInfoPopup();
            break;
        }
      });
    };

    let transitionSpeed = 0.01;

    function updateTransitionSpeed(value) {
      transitionSpeed = parseFloat(value);
    }

    function showInfoPopup(text) {
      const infoPopup = document.getElementById('infoPopup');
      infoPopup.innerHTML = `
        <p>${text}</p>
        <button onclick="hideInfoPopup()" style="width: 100%; padding: 10px; background-color: #4CAF50; border: none; color: white; cursor: pointer; border-radius: 5px;">Close</button>
      `;
      infoPopup.style.display = 'block';
    }

    function hideInfoPopup() {
      const infoPopup = document.getElementById('infoPopup');
      infoPopup.style.display = 'none';
    }

    function updateScrollUI(percentage) {
      const scrollPercentage = document.getElementById('scrollPercentage');
      const progressBar = document.getElementById('progressBar');
      if (scrollPercentage && progressBar) {
        scrollPercentage.textContent = `${Math.round(percentage)}%`;
        progressBar.style.width = `${percentage}%`;
      }
    }

    const scrollButtonMode = 'waypoint';
    const scrollAmount = 10;

    function handleButtonScroll(direction) {
      if (cameraMode === 'explore') return;
      if (scrollButtonMode === 'percentage') {
        adjustScroll(direction * scrollAmount / 100);
      } else {
        moveToWaypoint(direction);
      }
    }

    function adjustScroll(amount) {
      const pathLength = path.length;
      if (pathLength > 1) {
        const scrollIncrement = (pathLength - 1) * amount;
        scrollTarget += scrollIncrement;
        if (scrollTarget < 0) scrollTarget = 0;
        if (scrollTarget > path.length - 1) scrollTarget = path.length - 1;
        userControl = false;
      }
    }

    function moveToWaypoint(direction) {
      const subdivisionsPerSegment = 20;
      let currentWaypointIndex = Math.round(scrollPosition / subdivisionsPerSegment);
      let nextWaypointIndex = currentWaypointIndex + direction;
      nextWaypointIndex = Math.max(0, Math.min(nextWaypointIndex, waypoints.length - 1));
      scrollTarget = nextWaypointIndex * subdivisionsPerSegment;
      userControl = false;
    }

    function createWaypointButtons() {
      const waypointControls = document.getElementById('waypointControls');
      waypoints.forEach((wp, index) => {
        const button = document.createElement('button');
        button.textContent = waypointNames[index] || `Waypoint ${index + 1}`;
        button.className = 'waypoint-button';
        button.addEventListener('click', () => {
          if (lastClickedButton && lastClickedButton !== button) {
            lastClickedButton.classList.remove('active');
          }
          button.classList.add('active');
          lastClickedButton = button;
          moveToSpecificWaypoint(index);
        });
        waypointControls.appendChild(button);
      });
    }

    function moveToSpecificWaypoint(waypointIndex) {
      if (animatingToPath) return;
      userControl = false;
      animatingToPath = true;
      const subdivisionsPerSegment = 20;
      const targetScrollPosition = waypointIndex * subdivisionsPerSegment;
      const targetPosition = new BABYLON.Vector3(
        waypoints[waypointIndex].x,
        waypoints[waypointIndex].y,
        waypoints[waypointIndex].z
      );
      const targetRotation = rotations[waypointIndex].clone();

      const positionAnimation = new BABYLON.Animation(
        "waypointPositionAnimation",
        "position",
        60,
        BABYLON.Animation.ANIMATIONTYPE_VECTOR3,
        BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
      );
      positionAnimation.setKeys([
        { frame: 0, value: camera.position.clone() },
        { frame: 120, value: targetPosition }
      ]);

      const rotationAnimation = new BABYLON.Animation(
        "waypointRotationAnimation",
        "rotationQuaternion",
        60,
        BABYLON.Animation.ANIMATIONTYPE_QUATERNION,
        BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
      );
      rotationAnimation.setKeys([
        { frame: 0, value: camera.rotationQuaternion.clone() },
        { frame: 120, value: targetRotation }
      ]);

      const easingFunction = new BABYLON.CubicEase();
      easingFunction.setEasingMode(BABYLON.EasingFunction.EASINGMODE_EASEINOUT);
      positionAnimation.setEasingFunction(easingFunction);
      rotationAnimation.setEasingFunction(easingFunction);

      camera.animations = [positionAnimation, rotationAnimation];
      scene.beginAnimation(camera, 0, 120, false, 1, () => {
        scrollPosition = targetScrollPosition;
        scrollTarget = targetScrollPosition;
        animatingToPath = false;
        updateWaypointText(waypointIndex);
      });
    }

    function updateWaypointText(index) {
      const waypointTextSpan = document.querySelector('#waypointText .text-content');
      const descriptions = [
        "Beachfront with loads of greenery", // Waypoint 6
        "Take in soothing sunsets from the Pier", // Waypoint 7
        "Lawn + Stage Aerial View", // Waypoint 8
        "Managed parking to accomodate all your guests' vehicles", // Waypoint 9
        "Beachfront Restaurant", // Waypoint 10
        "Seaside Bungalows", // Waypoint 11
        "Lush green lawn with large stage for functions", // Waypoint 1
        "Thoughtfully designed to provide your guests the best experience", // Waypoint 2
        "Located right by the Pool side, everything is close by", // Waypoint 3
        "Hear the crashing of waves from the private beach just outside", // Waypoint 4
        "Relax by the serene Pool View",                  // Waypoint 5
      ];
      waypointTextSpan.textContent = descriptions[index] || "No description available";
    }

    window.addEventListener('wheel', (event) => {
      if (animatingToPath) return;
      if ((cameraMode === 'auto' && userControl) || (cameraMode === 'tour' && userControl)) {
        animatingToPath = true;
        userControl = false;
        if (!camera.rotationQuaternion) {
          camera.rotationQuaternion = BABYLON.Quaternion.FromEulerAngles(
            camera.rotation.x,
            camera.rotation.y,
            camera.rotation.z
          ).normalize();
          camera.rotation.set(0, 0, 0);
        }
        const targetT = scrollPosition;
        const pathLength = path.length - 1;
        const floorIndex = Math.floor(targetT);
        const ceilIndex = Math.min(floorIndex + 1, pathLength);
        const lerpFactor = targetT - floorIndex;
        const targetPosition = BABYLON.Vector3.Lerp(path[floorIndex], path[ceilIndex], lerpFactor);
        let targetRotation = camera.rotationQuaternion.clone();
        if (rotations.length >= 2 && path.length >= 2) {
          const totalSegments = waypoints.length - 1;
          const segmentT = (targetT / pathLength) * totalSegments;
          const segmentIndex = Math.floor(segmentT);
          const clampedSegmentIndex = Math.min(segmentIndex, totalSegments - 1);
          const lerpFactorRot = segmentT - clampedSegmentIndex;
          const r1 = rotations[clampedSegmentIndex];
          const nextIndex = (clampedSegmentIndex + 1) % rotations.length;
          const r2 = rotations[nextIndex];
          targetRotation = BABYLON.Quaternion.Slerp(r1, r2, lerpFactorRot).normalize();
        } else if (rotations.length === 1) {
          targetRotation = rotations[0];
        }
        const positionAnimation = new BABYLON.Animation(
          'cameraPositionAnimation',
          'position',
          60,
          BABYLON.Animation.ANIMATIONTYPE_VECTOR3,
          BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
        );
        positionAnimation.setKeys([
          { frame: 0, value: camera.position.clone() },
          { frame: 120, value: targetPosition.clone() }
        ]);
        const easingFunction = new BABYLON.CubicEase();
        easingFunction.setEasingMode(BABYLON.EasingFunction.EASINGMODE_EASEINOUT);
        positionAnimation.setEasingFunction(easingFunction);
        const rotationAnimation = new BABYLON.Animation(
          'cameraRotationAnimation',
          'rotationQuaternion',
          60,
          BABYLON.Animation.ANIMATIONTYPE_QUATERNION,
          BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
        );
        rotationAnimation.setKeys([
          { frame: 0, value: camera.rotationQuaternion.clone() },
          { frame: 120, value: targetRotation }
        ]);
        rotationAnimation.setEasingFunction(easingFunction);
        camera.animations = [positionAnimation, rotationAnimation];
        scene.beginAnimation(camera, 0, 120, false, 1, () => {
          animatingToPath = false;
          scrollPosition = targetT;
          scrollTarget = targetT;
        });
      } else if (cameraMode !== 'explore') {
        scrollTarget += event.deltaY * 0.1;
        if (scrollTarget < 0) scrollTarget = 0;
        if (scrollTarget > path.length - 1) scrollTarget = path.length - 1;
      }
    });

    let targetRotation = camera.rotationQuaternion.clone();
    let targetPosition = camera.position.clone();
    const activeWaypoints = new Set();

    BABYLON.SceneLoader.ImportMeshAsync(
      '',
      'assets/data/Bambolim/',
      'BambolimAirAntiFlythoughScaled.splat',
      scene
    ).then((result) => {
      const loadedMeshes = result.meshes;
      loadedMeshes.forEach((mesh) => {
        if (mesh instanceof BABYLON.Mesh) {
          mesh.position = BABYLON.Vector3.Zero();
        }
      });
      preloader.classList.add('hidden');
      createWaypointButtons();
      updateWaypointText(0);
    }).catch((error) => {
      console.error('Error loading model file:', error);
      alert('Error loading model file: ' + error.message);
      preloader.classList.add('hidden');
      createWaypointButtons();
      updateWaypointText(0);
    });

    engine.runRenderLoop(function () {
      const scrollInterpolationSpeed = 0.01 + transitionSpeed * 0.1;
      if (autoPlayEnabled && !userControl) {
        scrollTarget += autoPlaySpeed;
      }
      scrollPosition += (scrollTarget - scrollPosition) * scrollInterpolationSpeed;
      if (loopMode) {
        if (scrollPosition >= path.length - 1.1) {
          scrollPosition = 0.2;
          scrollTarget = 0.2;
        } else if (scrollPosition <= 0.1) {
          scrollPosition = path.length - 1.11;
          scrollTarget = path.length - 1.11;
        }
      }
      scrollPosition = Math.max(0, Math.min(scrollPosition, path.length - 1));
      const scrollPercentage = (scrollPosition / (path.length - 1 || 1)) * 100;
      if (cameraMode !== 'explore') {
        updateScrollUI(scrollPercentage);
      }
      if ((cameraMode === 'auto' && !userControl) || (cameraMode === 'tour' && !userControl)) {
        const t = scrollPosition / (path.length - 1 || 1);
        const totalSegments = waypoints.length - 1;
        if (totalSegments >= 1) {
          const segmentT = t * totalSegments;
          const segmentIndex = Math.floor(segmentT);
          const clampedSegmentIndex = Math.min(segmentIndex, totalSegments - 1);
          const lerpFactor = segmentT - clampedSegmentIndex;
          const r1 = rotations[clampedSegmentIndex];
          const nextIndex = (clampedSegmentIndex + 1) % rotations.length;
          const r2 = rotations[nextIndex];
          targetRotation = BABYLON.Quaternion.Slerp(r1, r2, lerpFactor).normalize();
          const floorIndex = Math.floor(scrollPosition);
          const ceilIndex = Math.min(floorIndex + 1, path.length - 1);
          const lerpFactorPos = scrollPosition - floorIndex;
          const interpolatedPosition = BABYLON.Vector3.Lerp(path[floorIndex], path[ceilIndex], lerpFactorPos);
          targetPosition = interpolatedPosition;
        } else if (rotations.length === 1) {
          targetRotation = rotations[0].clone();
          targetPosition = path[0].clone();
        }
        if (camera.rotationQuaternion) {
          camera.rotationQuaternion = BABYLON.Quaternion.Slerp(
            camera.rotationQuaternion,
            targetRotation,
            0.05
          ).normalize();
        }
        const positionDampingFactor = 0.1;
        camera.position = BABYLON.Vector3.Lerp(camera.position, targetPosition, positionDampingFactor);
        waypoints.forEach((wp, index) => {
          const distance = BABYLON.Vector3.Distance(
            camera.position,
            new BABYLON.Vector3(wp.x, wp.y, wp.z)
          );
          const triggerDistance = wp.triggerDistance ?? 1.0;
          if (distance <= triggerDistance) {
            if (!activeWaypoints.has(index)) {
              activeWaypoints.add(index);
              executeInteractions(wp.interactions, index);
            }
          } else {
            if (activeWaypoints.has(index)) {
              activeWaypoints.delete(index);
              reverseInteractions(wp.interactions);
            }
          }
        });
      }
      scene.render();
    });

    scene.onPointerObservable.add(function (evt) {
      if (evt.type === BABYLON.PointerEventTypes.POINTERDOWN) {
        if (cameraMode === 'explore' || cameraMode === 'auto') {
          userControl = true;
        } else {
          userControl = false;
        }
      }
    });

    window.addEventListener('keydown', function () {
      if (cameraMode === 'explore' || cameraMode === 'auto') {
        userControl = true;
      } else {
        userControl = false;
      }
    });

    const muteButton = document.getElementById('muteButton');
    muteButton.textContent = isMuted ? '🔇 Unmute' : '🔊 Mute';
    muteButton.addEventListener('click', function() {
      isMuted = !isMuted;
      muteButton.textContent = isMuted ? '🔇 Unmute' : '🔊 Mute';
      if (isMuted) {
        Object.values(activeSounds).forEach(sound => {
          if (sound.isPlaying) sound.pause();
        });
      } else {
        Object.values(activeSounds).forEach(sound => {
          if (!sound.isPlaying) sound.play();
        });
      }
    });

    document.getElementById('startButton').addEventListener('click', function() {
      document.getElementById('startButtonContainer').style.display = 'none';
      if (BABYLON.Engine.audioEngine.audioContext.state === 'suspended') {
        BABYLON.Engine.audioEngine.audioContext.resume();
      }
      waypoints.forEach((wp, index) => {
        wp.interactions.forEach((interaction) => {
          if (interaction.type === 'audio' && interaction.data.autoplay) {
            playAudio({ ...interaction.data, id: interaction.id }, index);
          }
        });
      });
    });

    window.addEventListener('resize', function () {
      engine.resize();
    });

    // Action button event listeners
    document.getElementById('resetViewButton').addEventListener('click', resetView);
    document.getElementById('exitButton').addEventListener('click', exitExperience);

    function resetView() {
      moveToSpecificWaypoint(0);
    }

    function exitExperience() {
      window.location.reload();
    }
  </script>
</body>
</html>